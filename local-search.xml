<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>http与https协议</title>
    <link href="/2021/01/10/http%E4%B8%8Ehttps%E5%8D%8F%E8%AE%AE/"/>
    <url>/2021/01/10/http%E4%B8%8Ehttps%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="http详解"><a href="#http详解" class="headerlink" title="http详解"></a>http详解</h1><ul><li>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</li></ul><h2 id="详解http协议"><a href="#详解http协议" class="headerlink" title="详解http协议"></a>详解http协议</h2><h3 id="可以拆分成三个部分：超文本-传输-协议"><a href="#可以拆分成三个部分：超文本-传输-协议" class="headerlink" title="可以拆分成三个部分：超文本 传输 协议"></a>可以拆分成三个部分：超文本 传输 协议</h3><ul><li><p>协议:<br>  HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</p></li><li><p>传输:<br>  我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。<br>  http是一个双向协议<br>  数据虽然在a和b之间传输 但允许中间有中转或接力</p></li><li><p>超文本:<br> http传输的内容是超文本<br> 超文本：超越了普通文本的文本，他是文字，图片，视频等的混合体 最关键有超链接，能从一个超文本跳转到另一个超文本 html就是最常见的超文本</p></li></ul><ul><li>此时 我们可以对http进行更准确的定义：http是一个在计算机世界里专门在【两点】之间【传输】文字，图片，音频，视频等【超文本】数据的【约定和规范】</li></ul><h3 id="问题：那「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-，这种说法正确吗？"><a href="#问题：那「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-，这种说法正确吗？" class="headerlink" title="问题：那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？"></a>问题：那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」 ，这种说法正确吗？</h3><ul><li>这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。</li></ul><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul><li><p>1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p></li><li><p>2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。<br>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。<br>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。<br>「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li><li><p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。<br>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br>「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p></li><li><p>4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。<br>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。<br>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。<br>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li><li><p>5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。<br>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。<br>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。<br>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。<br>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p></li></ul><h3 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h3><ul><li><p>host：客户端发送请求时，用来指定服务器的域名</p></li><li><p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</p></li><li><p>Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。<br>  HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive</p></li><li><p>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p></li><li><p>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p></li></ul><h2 id="get与post"><a href="#get与post" class="headerlink" title="get与post"></a>get与post</h2><ul><li><p>说一下 GET 和 POST 的区别？</p><p> Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。<br> 比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。<br> 而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。<br> 比如，你在我文章底部，敲入了留言后点击「提交」，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。</p></li></ul><ul><li><p>GET与POST在传输过程中是安全和幂等的吗？</p><p>  GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<br>  POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 </p></li></ul><blockquote><p>先说明下安全和幂等的概念：<br>    在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。<br>    所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p></blockquote><h2 id="http特性"><a href="#http特性" class="headerlink" title="http特性"></a>http特性</h2><ul><li><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」</p><p>  简单：HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。</p><p>  灵活易于拓展：HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。<br>  同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。<br>  HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。</p><p>  应用广泛和跨平台：互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。</p></li><li><p>HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」</p><p>  无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。<br>  无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。<br>  例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。<br>  这样每操作一次，都要验证信息，这样的购物体验还能愉快吗？别问，问就是酸爽！<br>  对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。<br>  Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。<br>  相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了了。</p><p>  明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。<br>  但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。</p><p>  HTTP 比较严重的缺点就是不安全：<br>  通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。<br>  不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。<br>  无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。<br>  HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</p></li></ul><ul><li><p>http性能：HTTP 协议是基于 TCP/IP，并且使用了「请求 - 应答」的通信模式，所以性能的关键就在这两点里</p><p>  早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。<br>  为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。<br>  持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p><p>  HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。<br>  即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。<br>  举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。<br>  但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</p><p>  「请求 - 应答」的模式加剧了 HTTP 的性能问题。<br>  因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。<br>  总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。</p></li></ul><h2 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h2><ul><li><p>http与https的区别<br>  HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。<br>  HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。<br>  HTTP 的端口号是 80，HTTPS 的端口号是 443。<br>  HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></li><li><p>https解决了哪些问题<br>  信息加密：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。<br>  校验机制：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。<br>  身份证书：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</p></li><li><p>https如何解决上面三个问题<br>  混合加密的方式实现信息的机密性，解决了窃听的风险。<br>  摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。<br>  将服务器公钥放入到数字证书中，解决了冒充的风险。</p></li><li><p>https如何建立的<br>  SSL/TLS 协议基本流程：<br>  客户端向服务器索要并验证服务器的公钥。<br>  双方协商生产「会话秘钥」。<br>  双方采用「会话秘钥」进行加密通信。                                      前两步是ssl/tls的建立过程 也就是握手阶段</p></li></ul><h2 id="html演变"><a href="#html演变" class="headerlink" title="html演变"></a>html演变</h2><ul><li><p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<br>  使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。<br>  支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p></li><li><p>但 HTTP/1.1 还是有性能瓶颈：<br>  请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；<br>  发送冗长的首部。每次互相发送相同的首部造成的浪费较多；<br>  服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；<br>  没有请求优先级控制；<br>  请求只能从客户端开始，服务器只能被动响应。</p></li><li><p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的</p><ul><li>头部压缩<br>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。<br>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li><li>二进制格式<br>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。<br>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。<br>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</li><li>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>每个请求或回应的所有数据包，称为一个数据流（Stream）。<br>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数<br>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</li><li>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。<br>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。<br>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</li><li>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。<br>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</li></ul></li><li><p>HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</p><ul><li>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。<br>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<br>  HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了<br>  HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li><li>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！<br>UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的一个丢包全部重传问题。<br>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。<br>  QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。<br>  TL3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack。<br>  HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。<br>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。<br>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>互联网</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器是如何运作的？</title>
    <link href="/2021/01/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%EF%BC%9F/"/>
    <url>/2021/01/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="关于浏览器在运作时的流程"><a href="#关于浏览器在运作时的流程" class="headerlink" title="关于浏览器在运作时的流程"></a>关于浏览器在运作时的流程</h1><a id="more"></a><h1 id="浏览器是如何运作的"><a href="#浏览器是如何运作的" class="headerlink" title="浏览器是如何运作的"></a>浏览器是如何运作的</h1><ul><li>我们要理解浏览器是如何运作的过程，首先要理解一个概念，也就是进程与线程</li></ul><blockquote><p> 进程是操作系统进行资源分配和调度的基本单元 可以申请和拥有计算机资源 进程是程序的基本执行实体<br>线程是操作系统能够进行运算调度的最小单位 一个进程中可以并发多个线程 每条线程并行执行不同的任务</p></blockquote><ul><li><p>在我们了解了进程与线程的概念以后，就可以和你介绍浏览器的运作流程了</p></li><li><p>当我们在电脑上打开打了浏览器时，相当于运行了浏览器这个应用程序</p><h2 id="浏览器的多进程结构"><a href="#浏览器的多进程结构" class="headerlink" title="浏览器的多进程结构"></a>浏览器的多进程结构</h2></li><li><p>而浏览器这个是一个多进程的浏览器结构，根据进程功能不同来拆分浏览器，我们可以将浏览器分解为：</p><p> 1.浏览器进程</p><pre><code> 负责控制浏览器除标签页外的用户界面  包括地址栏 书签 后退 和前进按钮 以及负责与浏览器的其他进程协调工作</code></pre><p> 2.GPU进程</p><pre><code> 负责整个浏览器界面的渲染</code></pre><p> 3.插件进程</p><pre><code> 负责控制网站使用的所有插件</code></pre><p> 4.缓存进程<br> 5.网络进程</p><pre><code>负责发起接受网络请求</code></pre><p> 6.渲染器进程</p><pre><code>用来控制显示tab标签内的所有内容 浏览器在默认情况下会为每个标签页创建一个渲染器进程</code></pre><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2></li><li><p>当你在浏览器地址栏输入地址时 浏览器的ui线程会捕捉你的输入内容<br>如果访问的是网址 则ui线程会启动一个网络线程来请求dns进行域名解析<br>接着连接服务器获取数据</p></li><li><p>当网络线程获取到数据后 会通过 safeBrowsing来检查站点（检查是否是恶意站点，会弹出警告） </p><p>   safebrowsing是谷歌内置的一套站点安全系统 通过检测该站点的数据来判断是否安全</p></li><li><p>当安全校验通过时 网络线程会通知ui线程准备好了 然后ui线程会创建一个渲染器进程来渲染页面 浏览器进程通过ipc管道将数据传递给渲染器进程</p></li><li><p>渲染器进程的核心任务就是把 html css js 等资源渲染成用户可以交互的web界面 渲染器进程的主线程将html进行解析 构造dom数据结构 在加载完成后 我们会获得一个dom tree</p></li><li><p>在知道dom的结构和每个节点的样式后 接下来需要知道每个节点放在页面上的哪个位置 也就是节点的坐标以及该节点需要占用多大的区域 这个阶段被称为layout布局 主线程通过遍历dom和计算好的样式来生成layout ree 上面的每个节点都记录了x y 坐标与边框尺寸 （这里注意dom tree 与layout tree并不是一一对应的 设置的display：none的节点并不会出现在layout tree上 而在before伪类添加了content值的元素会出现在layout tree 而不会出现在dom tree上）</p></li><li><p>为了保证在屏幕上展示正确的层级 主线程遍历layout tree创建一个绘制记录表 记录了绘制的顺序 该阶段被称为绘制 paint</p></li><li><p>主线程遍历layout tree 生成layer tree</p></li><li><p>主线程将这些layer tree 和绘制信息传递给合成器线程  合成器线程将他们切分为许多图块 然后将每个图块发送给栅格化线程 栅格化线程栅格化每个图块 并将他们存储在gpu内存中 当图块栅格化完成后 合成器线程将收集称为“draw quads”的图块信息 这些信息里记录了图块在内存中的位置 和在页面的那个位置绘制图块的信息 根据这些信息合成器线程生成了一个合成器帧 这个合成器帧通过ipc传送给浏览器进程 接着浏览器进程将合成器帧传送到gpu 然后gpu渲染展示到屏幕上 当页面发生变化 比如滚动页面 都会生成一个新的合成器帧 重复之前的流程</p></li><li><p>此时，你就可以看到显示在可视区域的图块了</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>为什么要尽量避免重绘和重排</p><p>   可能会导致掉帧 这是因为j有可能js执行阻塞了主线程 而css中有个动画属性叫transform 通过该属性实现的动画不会经过布局和绘制 而是直接运行在合成器线程和栅格化线程中 所以不会受到主线程中js执行的影响</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>互联网</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>互联网是如何运作的？</title>
    <link href="/2021/01/10/%E4%BA%92%E8%81%94%E7%BD%91%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <url>/2021/01/10/%E4%BA%92%E8%81%94%E7%BD%91%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="互联网运作"><a href="#互联网运作" class="headerlink" title="互联网运作"></a>互联网运作</h1> <a id="more"></a><h1 id="互联网时如何运作的"><a href="#互联网时如何运作的" class="headerlink" title="互联网时如何运作的"></a>互联网时如何运作的</h1><ul><li>我们在通过自己的个人客户端访问远程服务器时，都会经过一个流程，接下来我将通过介绍访问bilibili官网主页的形式，来介绍从自己的电脑来进行访问的过程</li></ul><h2 id="从自己电脑访问bilibili主页流程"><a href="#从自己电脑访问bilibili主页流程" class="headerlink" title="从自己电脑访问bilibili主页流程"></a>从自己电脑访问bilibili主页流程</h2><ul><li><p>1.当自己电脑连入互联网时，会获得一个ip地址（客户端）</p></li><li><p>2.访问的哔哩哔哩动画的服务器也接入互联网 同时也会有一个ip地址（服务端）</p></li><li><p>3.客户端在需要时通过互联网与服务端进行通信<br> 电脑发送信息给要访问的服务器 要获取的内容<br> 消息将被转换成电子信号 通过电缆放给服务器<br> 在服务器端将电子信号转换为计算机可以使用的文本数据</p></li></ul><hr><h2 id="关于TCP-IP协议"><a href="#关于TCP-IP协议" class="headerlink" title="关于TCP/IP协议"></a>关于TCP/IP协议</h2><ul><li>当然，上面的流程只是简述了通过自己电脑访问网站的几个关键步骤<br> 那么，自己的电脑到底是通过什么方法去连接到远程的服务器端并将信息传输的呢<br> 我们是通过统称为 TCP/IP协议族 一系列规则俩进行网络通信的</li></ul><blockquote><p>协议是一组规则 用于指定计算机 应如何通过网络进行通信</p></blockquote><h3 id="TCP-IP协议介绍"><a href="#TCP-IP协议介绍" class="headerlink" title="TCP/IP协议介绍"></a>TCP/IP协议介绍</h3><ul><li><p>TCP/IP协议一共分为四层，分别是：<br>  1.应用层</p><pre><code>  提供特定于应用程序的协议 HTTP FTP IMAP</code></pre><p>  2.TCP传输控制层</p><pre><code>  发送数据包到计算机上使用特定端口号的应用程序  tcp是一种面向连接的可靠字节流服务协议</code></pre><p>  3.IP网络层</p><pre><code>  使用IP地址将数据包发送到特定的计算机</code></pre><p>  4.链路层</p><pre><code>  将二进制数据包与网络信号相互之间转换</code></pre><h3 id="TCP-IP访问流程"><a href="#TCP-IP访问流程" class="headerlink" title="TCP/IP访问流程"></a>TCP/IP访问流程</h3></li><li><p>接下来我们还是使用访问哔哩哔哩官网来对流程进行介绍</p><ol><li><p> 使用应用层的http协议请求获取html文本 消息在发送前会被分解成许多片段 称为数据包</p></li><li><p> 通过应用层进入tcp层后 每个数据包都会被分配一个端口号</p></li><li><p> 进入ip层后 每个数据包将会赋予目标计算机的ip地址</p></li><li><p> 进入链路层后 将数据包的文本信息转译为电子信号 通过电缆发送</p></li><li><p>在电缆的另一端的路由器检查每个数据包中的目标地址<br>并确定将其发送到何处<br>最终数据包到达服务器<br>然后数据包从TCP/IP协议族的底部开始向上运行</p></li><li><p>当数据包开始向上运行时<br>客户端添加的所有路由数据<br>如ip地址和端口号都将从数据包中剥离出来<br>当数据到达栈顶时 数据包恢复成最初始的形式<br>通过端口号可以将数据传递给当前服务器监听该端口的应用程序<br>应用程序根据当前请求数据做出反应<br>服务器将该网站的首页的数据通过刚才的方式返回给你得电脑</p></li></ol></li></ul><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><pre><code>当我们在进行访问远程地址时，通常都是由域名来进行对ip地址的绑定来进行访问</code></pre><ul><li>浏览器通过dns来将ip地址与域名识别<ul><li>dns是一个分布式数据库 上面记录了域名和其ip地址的对应关系</li><li>在浏览器中输入网址时 浏览器首先连接dns服务器 获取到该域名的ip地址后 浏览器再连接访问该ip的服务器</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>以上就是通过对访问哔哩哔哩来对互联网运作流程的一个简要介绍</li></ul><p> <a href="https://space.bilibili.com/2882171">bilibili主页</a><br> 图片测试<br> <img src="https://img.pic88.com/preview/2020/08/05/15966333861457328.jpg!s640" alt="图片"></p><p> <em>字体是倾斜的哦</em><br> <strong>字体加粗了呢</strong></p><p> <code>&lt;html&gt;&lt;/html&gt;</code><br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></p><blockquote><p>我的内容是引用的<br>还是一句引用</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>互联网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新文档</title>
    <link href="/2021/01/09/%E6%96%B0%E6%96%87%E6%A1%A3/"/>
    <url>/2021/01/09/%E6%96%B0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="这是我的第一篇博客"><a href="#这是我的第一篇博客" class="headerlink" title="这是我的第一篇博客"></a>这是我的第一篇博客</h1> <a id="more"></a><h3 id="这个是三级标题"><a href="#这个是三级标题" class="headerlink" title="这个是三级标题"></a>这个是三级标题</h3><ul><li>列表1</li><li>列表2<br> a 子列表<br> b 子列表</li><li>列表3</li></ul><hr><p> <a href="https://space.bilibili.com/2882171">bilibili主页</a><br> 图片测试<br> <img src="https://img.pic88.com/preview/2020/08/05/15966333861457328.jpg!s640" alt="图片"></p><p> <em>字体是倾斜的哦</em><br> <strong>字体加粗了呢</strong></p><p> <code>&lt;html&gt;&lt;/html&gt;</code><br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></p><blockquote><p>我的内容是引用的<br>还是一句引用</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
